"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamoTools = void 0;
const tslib_1 = require("tslib");
const AWS = require("aws-sdk");
const dayjs = require("dayjs");
const default_tabledef_json_1 = tslib_1.__importDefault(require("./default-tabledef.json"));
const DynamoDB = require('aws-sdk/clients/dynamodb');
const logger_1 = tslib_1.__importDefault(require("./logger"));
/**
 * Allows you to simplify your Test Integrations and customize your DAOs to what you need.  This will
 * allow you to create a Dynamo Table for testing, seed data etc.
 */
class DynamoTools {
    // public static GSI_LOOKUP = "GSIlookup";
    /**
     * Constructs the Tools.
     *
     * @param tableName
     * @param options DynamoOptions optionally used for local development (ie local stack).
     *                Pass in an empty {} to use the defaults
     */
    constructor(tableName, options) {
        this.tableName = tableName;
        this.initLocal(options);
    }
    initLocal(options) {
        const useLocal = process.env.LOCAL_DEV;
        if (options || useLocal) {
            const awsOptions = {
                region: options.region || "us-east-1",
                endpoint: options.localEndpoint || "http://localhost:4566"
            };
            AWS.config.update(awsOptions);
        }
    }
    deleteTable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tableName = this.tableName;
            const dynamoDB = new DynamoDB();
            try {
                yield dynamoDB.deleteTable({
                    TableName: tableName
                }).promise();
                logger_1.default.debug(`Deleted Table -> ${tableName}`);
            }
            catch (err) {
                logger_1.default.warn(`Tried to delete ${tableName} but it may not exist ${err}. Ignoring.`);
            }
        });
    }
    replacePlaceholders(srcString) {
        const replacements = {
            "%TABLENAME%": this.tableName
        };
        return srcString.replace(/%\w+%/g, (all) => {
            return replacements[all] || all;
        });
    }
    /**
     * Follows Alex Debrie's book on single table design using a pk/sk and "type".
     * Gives full flexibility to create access patterns but creates all of the
     * appropriate indexes etc to get you going.
     *
     * @param deleteTable true/false to delete the table before creating it
     * @param dynamoTableDefinition The AWS SDK parameter object structure to create your Dynamo Table.
     *
     * @returns The Result of the Created Table.
     */
    createTable(deleteTable = true, dynamoTableDefinition) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const tableName = this.tableName;
                let params;
                if (dynamoTableDefinition) {
                    params = dynamoTableDefinition;
                }
                else {
                    params = JSON.parse(this.replacePlaceholders(JSON.stringify(default_tabledef_json_1.default)));
                }
                if (deleteTable) {
                    yield this.deleteTable();
                }
                const dynamoDB = new DynamoDB();
                let tableResult;
                try {
                    tableResult = yield dynamoDB.createTable(params).promise();
                    logger_1.default.debug(`Table Created -> ${tableName}`);
                }
                catch (err) {
                    logger_1.default.error("Error creating DB.  DB may already exist", err);
                }
                return tableResult;
            }
            catch (err) {
                logger_1.default.error("Test Integration Table Setup error", err);
                throw err;
            }
        });
    }
    /**
     * Allows you to seed your table for your tests
     *
     * @param items
     * @param plugin
     */
    seedData(items, plugin) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Assert.ok(type != null, "type is a required field and must be an entity type name");
            const docClient = new AWS.DynamoDB.DocumentClient();
            const tableName = this.tableName;
            const batch = {
                RequestItems: {
                    [tableName]: []
                }
            };
            const MAX_BATCH_SIZE = 25; //https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#batchWriteItem-property
            for (const dataItem of items) {
                let item = dataItem;
                if (batch.RequestItems[tableName].length >= MAX_BATCH_SIZE) {
                    yield docClient.batchWrite(batch).promise();
                    batch.RequestItems[tableName] = [];
                }
                const now = dayjs();
                if (plugin) {
                    const newItem = yield plugin.beforeCreate(item);
                    if (!newItem) {
                        logger_1.default.warn("Item was not returned from beforeCreate, ignoring updates.");
                    }
                    else {
                        item = newItem;
                    }
                }
                let putRequest = {
                    PutRequest: {
                        Item: Object.assign(Object.assign({}, item), { cadt: now.toISOString(), uadt: now.toISOString() })
                    }
                };
                batch.RequestItems[tableName].push(putRequest);
            }
            // Include the last batch
            if (batch.RequestItems[tableName].length > 0) {
                yield docClient.batchWrite(batch).promise();
            }
            logger_1.default.debug(`Finished Creating Data`);
        });
    }
}
exports.DynamoTools = DynamoTools;
DynamoTools.GSI_SK = "GSIsk";
DynamoTools.GSI1_PK = "GSI1pk";
DynamoTools.GSI_TYPE = "GSItype";
//# sourceMappingURL=DynamoTools.js.map